"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.Enum = void 0;
var _is = require("@voidvolker/is");
// Generated by CoffeeScript 2.7.0
var Enum, hasProp, nullObj;
hasProp = Object.prototype.hasOwnProperty;
nullObj = function () {
  return Object.create(null);
};
exports.Enum = Enum = function () {
  class Enum {
    constructor(pairs, arr, options = {}) {
      var i, key, len, opt, value;
      this.key = nullObj();
      this.value = nullObj();
      // In case of 2 arguments move 'options' from 'arr' (arr/obj and options)
      if ((0, _is.isObject)(arr)) {
        options = arr;
        arr = null;
      }
      // In case of 1 or 2 arguments move 'arr' from 'obj' (arr, obj and arr; first case)
      if ((0, _is.isArray)(pairs)) {
        arr = pairs;
        pairs = null;
      }
      opt = Object.assign({}, this.constructor.default, Enum.default, options);
      this.i = opt.i;
      if (opt.next) {
        this.next = opt.next;
      }
      // Process key-value pairs
      if (pairs) {
        for (key in pairs) {
          value = pairs[key];
          if (hasProp.call(this.value, value)) {
            throw new TypeError(`Enum '${key}: ${value}' value already defined as: '${this.value[value]}: ${value}'`);
          }
          if (!(0, _is.isNumber)(value)) {
            throw new TypeError('Only number type enum value is allowed: ' + value);
          }
          this.key[key] = value;
          this.value[value] = key;
          this.i = value;
        }
      }
      // Process keys with autoincrement
      if (arr) {
        for (i = 0, len = arr.length; i < len; i++) {
          key = arr[i];
          while (hasProp.call(this.value, this.i.toString())) {
            this.next();
          }
          if (!(0, _is.isString)(key)) {
            throw new TypeError(`Only string enum name is allowed: ${key}<${(0, _is.typeGet)(key)}>`);
          }
          if (hasProp.call(this.key, key)) {
            throw new TypeError(`Enum '${key}: ${this.i}' name already defined as: '${key}: ${this.key[key]}'`);
          }
          this.key[key] = this.i;
          this.value[this.i] = key;
        }
        this.next();
      }
    }
    forKeys(cb, thisArg) {
      var key;
      thisArg = thisArg || this;
      for (key in this.key) {
        cb.call(thisArg, key);
      }
      return this;
    }
    forValues(cb, thisArg) {
      var key, ref, value;
      thisArg = thisArg || this;
      ref = this.key;
      for (key in ref) {
        value = ref[key];
        cb.call(thisArg, value);
      }
      return this;
    }
    forEach(cb, thisArg) {
      var key, ref, value;
      thisArg = thisArg || this;
      ref = this.key;
      for (key in ref) {
        value = ref[key];
        cb.call(thisArg, key, value);
      }
      return this;
    }
    keys() {
      var key, results;
      results = [];
      for (key in this.key) {
        results.push(key);
      }
      return results;
    }
    values() {
      var key, ref, results, value;
      ref = this.key;
      results = [];
      for (key in ref) {
        value = ref[key];
        results.push(value);
      }
      return results;
    }
    hasKey(key) {
      return hasProp.call(this.key, key);
    }
    hasValue(value) {
      return hasProp.call(this.value, value);
    }
    raw() {
      var key, rawEnm, ref, value;
      rawEnm = nullObj();
      ref = this.key;
      for (key in ref) {
        value = ref[key];
        rawEnm[key] = value;
        rawEnm[value] = key;
      }
      rawEnm[Enum.index] = this.i;
      return rawEnm;
    }
    static next() {
      return this.i++;
    }

    // Enum initiated from global counter
    static new(obj, arr, options = {}) {
      var enm;
      // In case of 2 arguments move 'options' from 'arr' (arr/obj and options)
      if ((0, _is.isObject)(arr)) {
        options = arr;
        arr = null;
      }
      if (!options.hasOwnProperty('i')) {
        // Set global counter
        options.i = this.i;
      }
      // Create new enum using global counter and this as constructor
      enm = new this(obj, arr, options);
      this.i = enm.i;
      return enm;
    }
    static raw(obj, arr, options) {
      return new this(obj, arr, options).raw();
    }
    static fromRaw(rawEnm) {
      var key, keys, value;
      keys = {};
      for (key in rawEnm) {
        value = rawEnm[key];
        if ((0, _is.isNumber)(value)) {
          keys[key] = value;
        }
      }
      return new this(keys);
    }
  }
  ;
  Enum.default = {
    i: 0
  };
  Enum.prototype.next = Enum.next;

  // Index symbol for raw enums
  Enum.index = Symbol('i');

  // Global counter
  Enum.i = 0;
  return Enum;
}.call(this);
var _default = exports.default = Enum;
//# sourceMappingURL=enum.cjs.map